{"version":3,"sources":["Map.js","EntityInfo.js","EndScreen.js","App.js","serviceWorker.js","index.js"],"names":["Map","props","handleKeyDown","e","movementEnabled","key","dispatch","type","id","setTimeout","handleSquareClick","mapRef","React","createRef","this","current","focus","squares","squareStyle","height","squareSize","width","i","shownMap","length","j","square","hasOwnProperty","occupied","enemies","push","style","onClick","mapStyle","gridTemplateColumns","className","tabIndex","onKeyDown","ref","Component","Square","state","nextProps","setState","background","connect","maps","currentMapId","EntityInfo","bars","icon","entityIsPlayer","value","entity","exp","maxValue","lvl","barType","entityType","Math","floor","health","maxHealth","entityName","toUpperCase","slice","group","src","atk","def","Bar","relativeValue","shownInfoId","player","enemy","EndScreen","gameState","pathFinder","land","start","end","maxDistance","map","JSON","parse","stringify","y","x","prev","borderSquares","getPath","ele","path","newBorders","canMoveThrough","Terrain","createValley","mapH","mapW","newStrip","growWall","chance","wall","random","reducedChance","generateMap","landType","enemyNumbers","enemyStats","automaton","expBounty","ghoul","dryad","Object","coords","generateCoords","recursiveCounter","quantity","generateShownMap","borders","left","viewRange","top","right","bottom","initializeState","initialState","foundPath","store","createStore","action","moveEntity","newPlayer","newX","newY","Error","adversary","adversaryId","result","enemyHealth","dmg1","dmg2","won","battle","expCap","newMaps","assign","newState","newGameState","forEach","App","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.20e5f327.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./Map.css\";\r\nimport { connect } from \"react-redux\";\r\n\r\nlet mapStateToProps = state => {\r\n  return {\r\n    squareSize: state.squareSize,\r\n    shownMap: state.shownMap,\r\n    enemies: state.maps[state.currentMapId].enemies,\r\n    movementEnabled: state.movementEnabled\r\n  };\r\n};\r\n\r\nclass Map extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.mapRef = React.createRef();\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.mapRef.current.focus();\r\n  }\r\n\r\n  handleKeyDown = e => {\r\n    if (\r\n      this.props.movementEnabled &&\r\n      (e.key == \"ArrowLeft\" ||\r\n        e.key == \"ArrowUp\" ||\r\n        e.key == \"ArrowDown\" ||\r\n        e.key == \"ArrowRight\")\r\n    ) {\r\n      this.props.dispatch({\r\n        type: \"KEYDOWN\",\r\n        key: e.key,\r\n        id: \"player\"\r\n      });\r\n      setTimeout(\r\n        () =>\r\n          this.props.dispatch({\r\n            type: \"ENEMYTURN\"\r\n          }),\r\n        100\r\n      );\r\n    }\r\n  };\r\n\r\n  handleSquareClick = id => {\r\n    if (id == null) return;\r\n    this.props.dispatch({\r\n      type: \"SHOWINFO\",\r\n      id: id\r\n    });\r\n  };\r\n\r\n  render() {\r\n    let squares = [];\r\n    let squareStyle = {\r\n      height: this.props.squareSize + \"px\",\r\n      width: this.props.squareSize + \"px\"\r\n    };\r\n\r\n    for (let i = 0; i < this.props.shownMap.length; i++) {\r\n      for (let j = 0; j < this.props.shownMap[i].length; j++) {\r\n        let square = this.props.shownMap[i][j];\r\n        let type;\r\n        if (square.hasOwnProperty(\"occupied\")) {\r\n          if (square.occupied == \"player\") {\r\n            type = \"player\";\r\n          } else {\r\n            type = this.props.enemies[square.occupied].type;\r\n          }\r\n          squares.push(\r\n            <Square\r\n              type={type}\r\n              style={squareStyle}\r\n              key={i + \" \" + j}\r\n              onClick={() => this.handleSquareClick(square.occupied)}\r\n            />\r\n          );\r\n        } else {\r\n          type = square.type;\r\n          squares.push(\r\n            <Square type={type} style={squareStyle} key={i + \" \" + j} />\r\n          );\r\n        }\r\n      }\r\n    }\r\n    let mapStyle = {\r\n      gridTemplateColumns:\r\n        \"repeat(\" +\r\n        this.props.shownMap[0].length +\r\n        \", \" +\r\n        this.props.squareSize +\r\n        \"px)\",\r\n      width: this.props.shownMap[0].length * this.props.squareSize + \"px\",\r\n      height: this.props.shownMap.length * this.props.squareSize + \"px\"\r\n    };\r\n\r\n    return (\r\n      <div\r\n        className=\"map\"\r\n        style={mapStyle}\r\n        tabIndex=\"0\"\r\n        onKeyDown={this.handleKeyDown}\r\n        ref={this.mapRef}\r\n      >\r\n        {squares}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nclass Square extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      type: this.props.type\r\n    };\r\n  }\r\n\r\n  componentWillReceiveProps(nextProps) {\r\n    this.setState({ type: nextProps.type });\r\n  }\r\n\r\n  render() {\r\n    let style = this.props.style;\r\n\r\n    style = {\r\n      height: this.props.style.height\r\n    };\r\n    switch (this.state.type) {\r\n      case \"ground\":\r\n        style.background = \"#9c7711\";\r\n        break;\r\n      case \"grass\":\r\n        style.background = \"#7ec850\";\r\n        break;\r\n      case \"rock\":\r\n        style.background = \"#5c4e29\";\r\n        break;\r\n      case \"player\":\r\n        style.background = \"#4287f5\";\r\n        break;\r\n      case \"ghoul\":\r\n        style.background = \"#6e3434\";\r\n        break;\r\n      case \"automaton\":\r\n        style.background = \"#b51616\";\r\n        break;\r\n      case \"dryad\":\r\n        style.background = \"#214a26\";\r\n        break;\r\n      default:\r\n        style.background = \"#000000\";\r\n    }\r\n\r\n    return (\r\n      <div className=\"square\" style={style} onClick={this.props.onClick} />\r\n    );\r\n  }\r\n}\r\n\r\nexport default connect(mapStateToProps)(Map);\r\n","import React from \"react\";\r\nimport \"./EntityInfo.css\";\r\nimport { connect } from \"react-redux\";\r\n\r\nlet mapStateToProps = state => {\r\n  if (\r\n    state.shownInfoId == \"player\" ||\r\n    state.shownInfoId == null ||\r\n    state.maps[state.currentMapId].enemies[state.shownInfoId] == \"dead\"\r\n  ) {\r\n    return { player: state.player };\r\n  } else {\r\n    return {\r\n      player: state.player,\r\n      enemy: state.maps[state.currentMapId].enemies[state.shownInfoId]\r\n    };\r\n  }\r\n};\r\n\r\nlet ShownEntities = props => {\r\n  if (props.enemy == null) {\r\n    return (\r\n      <div className=\"infoContainer\">\r\n        <EntityInfo entity={props.player} type=\"player\" group=\"player\" />\r\n      </div>\r\n    );\r\n  } else {\r\n    return (\r\n      <div className=\"infoContainer\">\r\n        <EntityInfo entity={props.player} type=\"player\" group=\"player\" />\r\n        <EntityInfo\r\n          entity={props.enemy}\r\n          type={props.enemy.type}\r\n          group=\"enemy\"\r\n        />\r\n      </div>\r\n    );\r\n  }\r\n};\r\n\r\nlet EntityInfo = props => {\r\n  let bars = [];\r\n  let icon = `Portraits/${props.type}.gif`;\r\n  let entityIsPlayer = props.type == \"player\";\r\n  if (entityIsPlayer) {\r\n    bars.push(\r\n      <Bar\r\n        value={props.entity.exp}\r\n        maxValue={props.entity.lvl * 100}\r\n        barType=\"Exp\"\r\n        entityType=\"player\"\r\n      />\r\n    ); //exp needed for lvl up is level*100\r\n  }\r\n\r\n  let relativeHealth = Math.floor(\r\n    (props.entity.health / props.entity.maxHealth) * 100\r\n  );\r\n  bars.push(\r\n    <Bar\r\n      value={props.entity.health}\r\n      maxValue={props.entity.maxHealth}\r\n      barType=\"HP\"\r\n      entityType={entityIsPlayer ? \"player\" : \"enemy\"}\r\n    />\r\n  );\r\n\r\n  let entityName = null;\r\n  if (!entityIsPlayer) {\r\n    entityName = <h1>{props.type[0].toUpperCase() + props.type.slice(1)}</h1>;\r\n  }\r\n\r\n  return (\r\n    <div className={\"info \" + props.group}>\r\n      <img className=\"icon\" src={icon} />\r\n      {entityName}\r\n      {bars}\r\n      <h2>Atk:{props.entity.atk}</h2>\r\n      <h2>Def:{props.entity.def}</h2>\r\n    </div>\r\n  );\r\n};\r\n\r\nlet Bar = props => {\r\n  let relativeValue = `${(props.value / props.maxValue) * 100}%`;\r\n  return (\r\n    <div className={`bar ${props.entityType + props.barType}`}>\r\n      <div className=\"barValue\">\r\n        <h2>{`${props.barType}: ${props.value}`}</h2>\r\n      </div>\r\n      <span style={{ width: relativeValue }}></span>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default connect(mapStateToProps)(ShownEntities);\r\n","import React from \"react\";\r\nimport \"./EndScreen.css\";\r\nimport { connect } from \"react-redux\";\r\n\r\nlet mapStateToProps = state => {\r\n  return {\r\n    gameState: state.gameState\r\n  };\r\n};\r\n\r\nclass EndScreen extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n  }\r\n\r\n  render() {\r\n\r\n    return (\r\n      <div className=\"EndScreen\" style={(this.props.gameState!==\"playing\")?{\"z-index\":\"100\",\"opacity\":\"1\"}:{\"z-index\":\"-1\",\"opacity\":\"0\"}}>\r\n        <h1>{this.props.gameState}</h1>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default connect(mapStateToProps)(EndScreen);\r\n","import React from \"react\";\r\nimport \"./App.css\";\r\nimport { createStore } from \"redux\";\r\nimport { Provider } from \"react-redux\";\r\nimport Map from \"./Map\";\r\nimport ShownEntities from \"./EntityInfo\";\r\nimport EndScreen from \"./EndScreen\";\r\nimport { connect } from \"react-redux\";\r\n\r\n/*TODO:\r\n  \r\n*/\r\n\r\nlet pathFinder = (land, start, end, maxDistance) => {\r\n  let map = JSON.parse(JSON.stringify(land));\r\n  map[end.y][end.x].prev = \"end\";\r\n  let borderSquares = [end];\r\n\r\n  let getPath = ele => {\r\n    let path = [];\r\n    path.push(map[ele.y][ele.x].prev);\r\n\r\n    let i = 0;\r\n    let x = ele.x;\r\n    let y = ele.y;\r\n    while (map[y][x].prev !== \"end\" && i < maxDistance) {\r\n      switch (path[path.length - 1]) {\r\n        case \"ArrowDown\": {\r\n          y++;\r\n          break;\r\n        }\r\n        case \"ArrowLeft\": {\r\n          x--;\r\n          break;\r\n        }\r\n        case \"ArrowUp\": {\r\n          y--;\r\n          break;\r\n        }\r\n        case \"ArrowRight\": {\r\n          x++;\r\n          break;\r\n        }\r\n      }\r\n      i++;\r\n      path.push(map[y][x].prev);\r\n    }\r\n    if (i > maxDistance) {\r\n      throw \"Path is longer than max distance\";\r\n    }\r\n    return path;\r\n  };\r\n\r\n  for (let i = 0; i < maxDistance; i++) {\r\n    let newBorders = [];\r\n    for (let i = 0; i < borderSquares.length; i++) {\r\n      let ele = borderSquares[i];\r\n      if (ele.y + 1 == start.y && ele.x == start.x) {\r\n        map[ele.y + 1][ele.x].prev = \"ArrowUp\";\r\n        return getPath(start);\r\n      }\r\n      if (ele.y - 1 == start.y && ele.x == start.x) {\r\n        map[ele.y - 1][ele.x].prev = \"ArrowDown\";\r\n        return getPath(start);\r\n      }\r\n      if (ele.y == start.y && ele.x + 1 == start.x) {\r\n        map[ele.y][ele.x + 1].prev = \"ArrowLeft\";\r\n        return getPath(start);\r\n      }\r\n      if (ele.y == start.y && ele.x - 1 == start.x) {\r\n        map[ele.y][ele.x - 1].prev = \"ArrowRight\";\r\n        return getPath(start);\r\n      }\r\n\r\n      if (\r\n        ele.y + 1 < map.length &&\r\n        !map[ele.y + 1][ele.x].hasOwnProperty(\"prev\") &&\r\n        map[ele.y + 1][ele.x].canMoveThrough &&\r\n        !map[ele.y + 1][ele.x].hasOwnProperty(\"occupied\")\r\n      ) {\r\n        map[ele.y + 1][ele.x].prev = \"ArrowUp\";\r\n        newBorders.push({ y: ele.y + 1, x: ele.x });\r\n      }\r\n      if (\r\n        ele.y - 1 >= 0 &&\r\n        !map[ele.y - 1][ele.x].hasOwnProperty(\"prev\") &&\r\n        map[ele.y - 1][ele.x].canMoveThrough &&\r\n        !map[ele.y - 1][ele.x].hasOwnProperty(\"occupied\")\r\n      ) {\r\n        map[ele.y - 1][ele.x].prev = \"ArrowDown\";\r\n        newBorders.push({ y: ele.y - 1, x: ele.x });\r\n      }\r\n      if (\r\n        ele.x + 1 < map[0].length &&\r\n        !map[ele.y][ele.x + 1].hasOwnProperty(\"prev\") &&\r\n        map[ele.y][ele.x + 1].canMoveThrough &&\r\n        !map[ele.y][ele.x + 1].hasOwnProperty(\"occupied\")\r\n      ) {\r\n        map[ele.y][ele.x + 1].prev = \"ArrowLeft\";\r\n        newBorders.push({ y: ele.y, x: ele.x + 1 });\r\n      }\r\n      if (\r\n        ele.x - 1 >= 0 &&\r\n        !map[ele.y][ele.x - 1].hasOwnProperty(\"prev\") &&\r\n        map[ele.y][ele.x - 1].canMoveThrough &&\r\n        !map[ele.y][ele.x - 1].hasOwnProperty(\"occupied\")\r\n      ) {\r\n        map[ele.y][ele.x - 1].prev = \"ArrowRight\";\r\n        newBorders.push({ y: ele.y, x: ele.x - 1 });\r\n      }\r\n    }\r\n    borderSquares = newBorders;\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\nclass Terrain {\r\n  constructor(type) {\r\n    this.type = type;\r\n    switch (type) {\r\n      case \"grass\":\r\n      case \"ground\":\r\n        this.canMoveThrough = true;\r\n        break;\r\n      case \"rock\":\r\n        this.canMoveThrough = false;\r\n        break;\r\n      default:\r\n        throw type + \" is not a valid terrain type\";\r\n    }\r\n  }\r\n}\r\n\r\nlet createValley = (mapH = 20, mapW = 20) => {\r\n  let land = [];\r\n  //initialize valley as having only grass terrain\r\n  for (let i = 0; i < mapH; i++) {\r\n    let newStrip = [];\r\n    for (let j = 0; j < mapW; j++) {\r\n      newStrip.push(new Terrain(\"grass\"));\r\n    }\r\n    land.push(newStrip);\r\n  }\r\n  //!!IMPORTANT!! THIS FUNCTION MODIFIES THE LAND ARRAY\r\n  let growWall = (i, j, chance = 100) => {\r\n    let wall = (i, j, chance) => {\r\n      if (i < 0 || j < 0 || i >= mapH || j >= mapW) return false;\r\n      if (land[i][j].type === \"grass\") {\r\n        if (Math.floor(Math.random() * 100) < chance) {\r\n          land[i][j] = new Terrain(\"rock\");\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n\r\n    let reducedChance = chance-30;\r\n    if (wall(i - 1, j, chance)) growWall(i - 1, j, reducedChance);\r\n    if (wall(i + 1, j, chance)) growWall(i + 1, j, reducedChance);\r\n    if (wall(i, j - 1, chance)) growWall(i, j - 1, reducedChance);\r\n    if (wall(i, j + 1, chance)) growWall(i, j + 1, reducedChance);\r\n  };\r\n\r\n\r\n  //generate rock clusters\r\n  for (let i = 0; i < mapH; i++) {\r\n    for (let j = 0; j < mapW; j++) {\r\n      if (Math.floor(Math.random() * 40) === 0) {\r\n        land[i][j] = new Terrain(\"rock\");\r\n        growWall(i, j);\r\n      }\r\n    }\r\n  }\r\n\r\n  return land;\r\n};\r\n\r\nlet generateMap = (landType = \"valley\", mapH = 20, mapW = 20, enemyNumbers) => {\r\n  const enemyStats = {\r\n    automaton: {\r\n      maxHealth: 150,\r\n      health: 150,\r\n      atk: 11,\r\n      def: 4,\r\n      expBounty: 60\r\n    },\r\n    ghoul: {\r\n      maxHealth: 100,\r\n      health: 100,\r\n      atk: 12,\r\n      def: 2,\r\n      expBounty: 70\r\n    },\r\n    dryad: {\r\n      maxHealth: 70,\r\n      health: 70,\r\n      atk: 14,\r\n      def: 0,\r\n      expBounty: 80\r\n    }\r\n  };\r\n\r\n  let map = new Object();\r\n\r\n  switch (landType) {\r\n    case \"valley\": {\r\n      map.land = createValley(mapH, mapW);\r\n      break;\r\n    }\r\n    default: {\r\n      throw landType + \" is not a valid land type\";\r\n    }\r\n  }\r\n\r\n  map.enemies = [];\r\n\r\n  for (let i = 0; i < enemyNumbers.length; i++) {\r\n    for (let j = 0; j < enemyNumbers[i].quantity; j++) {\r\n      let generateCoords = (recursiveCounter = 0) => {\r\n        let coords = {\r\n          x: Math.floor(Math.random() * map.land[0].length),\r\n          y: Math.floor(Math.random() * map.land.length)\r\n        };\r\n\r\n        if (\r\n          map.land[coords.y][coords.x].canMoveThrough &&\r\n          !map.land[coords.y][coords.x].hasOwnProperty(\"occupied\")\r\n        ) {\r\n          return coords;\r\n        } else {\r\n          if (recursiveCounter < 100)\r\n            return generateCoords(recursiveCounter + 1);\r\n          else throw \"could not generate coordinates\";\r\n        }\r\n      };\r\n\r\n      let enemy = {\r\n        maxHealth: enemyStats[enemyNumbers[i].type].maxHealth,\r\n        health: enemyStats[enemyNumbers[i].type].health,\r\n        atk: enemyStats[enemyNumbers[i].type].atk,\r\n        def: enemyStats[enemyNumbers[i].type].def,\r\n        expBounty: enemyStats[enemyNumbers[i].type].expBounty,\r\n        type: enemyNumbers[i].type,\r\n        id: map.enemies.length,\r\n        coords: generateCoords()\r\n      };\r\n      map.enemies.push(enemy);\r\n      map.land[enemy.coords.y][enemy.coords.x].occupied = enemy.id;\r\n    }\r\n  }\r\n  return map;\r\n};\r\n\r\nlet generateShownMap = (state, currentMapId = 0) => {\r\n  let borders = {\r\n    //borders indicate the last visible squares, and are included in the visible map\r\n    left: state.player.coords.x - state.viewRange,\r\n    top: state.player.coords.y - state.viewRange,\r\n    right: state.player.coords.x + state.viewRange,\r\n    bottom: state.player.coords.y + state.viewRange\r\n  };\r\n\r\n  let mapW = state.maps[currentMapId].land[0].length;\r\n  let mapH = state.maps[currentMapId].land.length;\r\n\r\n  if (mapW > state.viewRange * 2 + 1) {\r\n    if (borders.left < 0) {\r\n      borders.right = state.viewRange * 2;\r\n      borders.left = 0;\r\n    }\r\n\r\n    if (borders.right > mapW - 1) {\r\n      borders.right = mapW - 1;\r\n      borders.left = borders.right - state.viewRange * 2;\r\n    }\r\n  } else {\r\n    borders.left = 0;\r\n    borders.right = mapW - 1;\r\n  }\r\n\r\n  if (mapH > state.viewRange * 2 + 1) {\r\n    if (borders.top < 0) {\r\n      borders.bottom = state.viewRange * 2;\r\n      borders.top = 0;\r\n    }\r\n\r\n    if (borders.bottom > mapH - 1) {\r\n      borders.bottom = mapH - 1;\r\n      borders.top = borders.bottom - state.viewRange * 2;\r\n    }\r\n  } else {\r\n    borders.top = 0;\r\n    borders.bottom = mapH - 1;\r\n  }\r\n\r\n  let shownMap = [];\r\n  for (let y = borders.top; y <= borders.bottom; y++) {\r\n    let newStrip = [];\r\n    for (let x = borders.left; x <= borders.right; x++) {\r\n      let square = state.maps[currentMapId].land[y][x];\r\n      newStrip.push(square);\r\n    }\r\n    shownMap.push(newStrip);\r\n  }\r\n\r\n  return shownMap;\r\n};\r\n\r\nconst initializeState = (mapW = 30, mapH = 30) => {\r\n  let foundPath = false;\r\n  let initialState;\r\n\r\n  while (!foundPath) {\r\n    //we check that every enemy is reachable by the player\r\n    let player = {\r\n      exp: 0,\r\n      lvl: 1,\r\n      maxHealth: 100,\r\n      health: 100,\r\n      atk: 10,\r\n      def: 10,\r\n      id: \"player\"\r\n    };\r\n\r\n    let enemyNumbers = [\r\n      {\r\n        quantity: 7,\r\n        type: \"automaton\"\r\n      },\r\n      {\r\n        quantity: 6,\r\n        type: \"ghoul\"\r\n      },\r\n      {\r\n        quantity: 5,\r\n        type: \"dryad\"\r\n      }\r\n    ];\r\n\r\n    let map = generateMap(\"valley\", mapH, mapW, enemyNumbers);\r\n\r\n    let generateCoords = (recursiveCounter = 0) => {\r\n      let coords = {\r\n        x: Math.floor(Math.random() * map.land[0].length),\r\n        y: Math.floor(Math.random() * map.land.length)\r\n      };\r\n\r\n      if (\r\n        map.land[coords.y][coords.x].canMoveThrough &&\r\n        !map.land[coords.y][coords.x].hasOwnProperty(\"occupied\")\r\n      ) {\r\n        return coords;\r\n      } else {\r\n        if (recursiveCounter < 50) return generateCoords(recursiveCounter + 1);\r\n        else throw \"could not generate coordinates\";\r\n      }\r\n    };\r\n\r\n    player.coords = generateCoords();\r\n\r\n    for (let i = 0; i < map.enemies.length; i++) {\r\n      foundPath = pathFinder(\r\n        map.land,\r\n        player.coords,\r\n        map.enemies[i].coords,\r\n        (mapH * mapW) / 2\r\n      );\r\n      if (foundPath === false) break;\r\n    }\r\n\r\n    initialState = {\r\n      gameState: \"playing\",\r\n      maps: [map],\r\n      squareSize: 40,\r\n      viewRange: 5,\r\n      currentMapId: 0,\r\n      shownInfoId: null,\r\n      player: player,\r\n      movementEnabled: true\r\n      //shownMap\r\n    };\r\n  }\r\n\r\n  initialState.maps[0].land[initialState.player.coords.y][\r\n    initialState.player.coords.x\r\n  ].occupied = \"player\";\r\n\r\n  initialState.shownMap = generateShownMap(initialState);\r\n\r\n  return initialState;\r\n};\r\n\r\nfunction reducer(state = initializeState(), action) {\r\n  /*\r\n    @params:  the map, including enemies data\r\n              the moving entity\r\n              the key pressed (or simulated) to move the entity\r\n              newPlayer is needed if entity is not the player to allow for a battle, \r\n                as the playier is not included in the map parameter\r\n\r\n    @return:  gamestate, can be \"playing\", \"Game Over\" or \"Victory\"\r\n  */\r\n  let moveEntity = (map, entity, key, newPlayer) => {\r\n    let newX = entity.coords.x;\r\n    let newY = entity.coords.y;\r\n    if (!newPlayer && !entity.id === \"player\") {\r\n      throw new Error(\r\n        \"moveEntity needs a newPlayer argument if entity is not the player\"\r\n      );\r\n    }\r\n    switch (key) {\r\n      case \"ArrowLeft\":\r\n        if (newX <= 0) return \"playing\";\r\n        newX--;\r\n        break;\r\n      case \"ArrowUp\":\r\n        if (newY <= 0) return \"playing\";\r\n        newY--;\r\n        break;\r\n      case \"ArrowRight\":\r\n        if (newX >= map.land[0].length - 1) return \"playing\";\r\n        newX++;\r\n        break;\r\n      case \"ArrowDown\":\r\n        if (newY >= map.land.length - 1) return \"playing\";\r\n        newY++;\r\n        break;\r\n      default:\r\n        return \"playing\";\r\n    }\r\n\r\n    if (!map.land[newY][newX].canMoveThrough) return \"playing\";\r\n\r\n    let battle = (entity, enemy) => {\r\n      let health = entity.health;\r\n      let enemyHealth = enemy.health;\r\n      let dmg1 = entity.atk - enemy.def;\r\n      if (dmg1 < 0) dmg1 = 0;\r\n      let dmg2 = enemy.atk - entity.def;\r\n      if (dmg2 < 0) dmg2 = 0;\r\n\r\n      let result;\r\n      while (health > 0) {\r\n        enemyHealth -= dmg1;\r\n        if (enemyHealth > 0) {\r\n          health -= dmg2;\r\n        } else {\r\n          return {\r\n            won: true,\r\n            health: health,\r\n            enemyHealth: 0\r\n          };\r\n        }\r\n      }\r\n      return {\r\n        won: false,\r\n        health: 0,\r\n        enemyHealth: enemyHealth\r\n      };\r\n    };\r\n\r\n    if (map.land[newY][newX].hasOwnProperty(\"occupied\")) {\r\n      let adversary;\r\n      let adversaryId = map.land[newY][newX].occupied;\r\n      if (adversaryId == \"player\") {\r\n        adversary = newPlayer;\r\n      } else {\r\n        adversary = map.enemies[adversaryId];\r\n      }\r\n      let result = battle(entity, adversary);\r\n      if (\r\n        (!result.won && entity.id == \"player\") ||\r\n        (result.won && adversary.id == \"player\")\r\n      ) {\r\n        return \"Game Over\"; //!TODO: remove and to add a game over screen\r\n      } else {\r\n        if (entity.id == \"player\") {\r\n          entity.health = result.health;\r\n          entity.exp += map.enemies[adversary.id].expBounty;\r\n          let expCap = entity.lvl * 100;\r\n          while (entity.exp > expCap) {\r\n            entity.exp -= expCap;\r\n            entity.lvl++;\r\n            entity.atk++;\r\n            entity.def++;\r\n            expCap += 100;\r\n          }\r\n          map.enemies[adversary.id] = \"dead\";\r\n\r\n          map.land[newY][newX].occupied =\r\n            map.land[entity.coords.y][entity.coords.x].occupied;\r\n          delete map.land[entity.coords.y][entity.coords.x].occupied;\r\n\r\n          entity.coords.x = newX;\r\n          entity.coords.y = newY;\r\n        } else {\r\n          adversary.health = result.enemyHealth;\r\n          adversary.exp += map.enemies[entity.id].expBounty;\r\n          let expCap = adversary.lvl * 100;\r\n          while (adversary.exp > expCap) {\r\n            adversary.exp -= expCap;\r\n            adversary.lvl++;\r\n            adversary.atk++;\r\n            adversary.def++;\r\n            expCap += 100;\r\n          }\r\n          map.enemies[entity.id] = \"dead\";\r\n          delete map.land[entity.coords.y][entity.coords.x].occupied;\r\n        }\r\n        for (let enemy of map.enemies) {\r\n          if (enemy !== \"dead\") return \"playing\";\r\n        }\r\n        return \"Victory\";\r\n      }\r\n    } else {\r\n      map.land[newY][newX].occupied =\r\n        map.land[entity.coords.y][entity.coords.x].occupied;\r\n      delete map.land[entity.coords.y][entity.coords.x].occupied;\r\n\r\n      entity.coords.x = newX;\r\n      entity.coords.y = newY;\r\n    }\r\n    return \"playing\";\r\n  };\r\n\r\n  switch (action.type) {\r\n    case \"KEYDOWN\": {\r\n      if (state.gameState !== \"playing\") return state;\r\n      let newGameState = state.gameState;\r\n      let newMaps = JSON.parse(JSON.stringify(state.maps));\r\n      let map = newMaps[state.currentMapId];\r\n      let newPlayer = Object.assign({}, state.player);\r\n\r\n      newGameState = moveEntity(map, newPlayer, action.key);\r\n\r\n      let newState = {\r\n        gameState: newGameState,\r\n        maps: newMaps,\r\n        squareSize: state.squareSize,\r\n        viewRange: state.viewRange,\r\n        currentMapId: state.currentMapId,\r\n        player: newPlayer,\r\n        shownInfoId: state.shownInfoId,\r\n        movementEnabled: false\r\n      };\r\n      newState.shownMap = generateShownMap(newState);\r\n\r\n      return newState;\r\n    }\r\n    case \"ENEMYTURN\": {\r\n      if (state.gameState !== \"playing\") return state;\r\n      let newGameState = state.gameState;\r\n      let newMaps = JSON.parse(JSON.stringify(state.maps));\r\n      let map = newMaps[state.currentMapId];\r\n      let newPlayer = Object.assign({}, state.player);\r\n\r\n      map.enemies.forEach(enemy => {\r\n        if (enemy !== \"dead\") {\r\n          let path = pathFinder(map.land, enemy.coords, newPlayer.coords, 5);\r\n          if (path) {\r\n            newGameState = moveEntity(map, enemy, path[0], newPlayer);\r\n          }\r\n        }\r\n      });\r\n\r\n      let newState = {\r\n        gameState: newGameState,\r\n        maps: newMaps,\r\n        squareSize: state.squareSize,\r\n        viewRange: state.viewRange,\r\n        currentMapId: state.currentMapId,\r\n        player: newPlayer,\r\n        shownInfoId: state.shownInfoId,\r\n        movementEnabled: true\r\n      };\r\n      newState.shownMap = generateShownMap(newState);\r\n\r\n      return newState;\r\n    }\r\n    case \"SHOWINFO\": {\r\n      let newState = {\r\n        gameState: state.gameState,\r\n        maps: state.maps,\r\n        squareSize: state.squareSize,\r\n        viewRange: state.viewRange,\r\n        currentMapId: state.currentMapId,\r\n        player: state.player,\r\n        shownMap: state.shownMap,\r\n        shownInfoId: action.id,\r\n        movementEnabled: state.movementEnabled\r\n      };\r\n      return newState;\r\n    }\r\n    case \"\": {\r\n      let newState = {\r\n        gameState: state.gameState,\r\n        maps: state.maps,\r\n        squareSize: state.squareSize,\r\n        viewRange: state.viewRange,\r\n        currentMapId: state.currentMapId,\r\n        player: state.player,\r\n        shownMap: state.shownMap,\r\n        shownInfoId: state.shownInfoId,\r\n        movementEnabled: state.movementEnabled\r\n      };\r\n      return newState;\r\n    }\r\n    default:\r\n      return state;\r\n  }\r\n\r\n  return state;\r\n}\r\n\r\nconst store = createStore(reducer);\r\n\r\nconst App = () => (\r\n  <Provider store={store}>\r\n    <div className=\"app\">\r\n      <EndScreen />\r\n      <ShownEntities />\r\n      <Map />\r\n    </div>\r\n  </Provider>\r\n);\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}